---

title: EVM Vault swaps

description: Description of performing Vault Swaps for EVM networks

---

import { Callout } from "@/components";

# EVM Vault swaps

## Overview

Initiating an EVM [Vault swap](vault-swaps#vault-swaps) is done by making a smart contract call to Chainflip's Vault contract. The contract addresses can be found in [Testnet addresses](../../../supported-chains-and-assets/testnet-addresses.mdx) and [Mainnet addresses](../../../supported-chains-and-assets/mainnet-addresses.mdx).


Encoding the contract call can be done via the `broker_request_swap_parameter_encoding()` RPC call. The call will return the encoded data needed to initiate the swap. The user can then sign and send the transaction to the network. Alternatively, the smart contract interface reference is provided for advanced users to manually call the Vault smart contract.


## Broker API

### EVM variant of `extra_parameters`

The follow is the definition of the Ethereum Variant of `extra_parameters`.

```rust
pub enum VaultSwapExtraParameters<Address, Amount> {
	Bitcoin {...},
	Ethereum(EvmVaultSwapExtraParameters<Address, Amount>),
	Arbitrum(EvmVaultSwapExtraParameters<Address, Amount>),
	Solana {...},
}

pub struct EvmVaultSwapExtraParameters<Address, Amount> {
    // The amount of Native or Token currencies to be swapped.
	pub input_amount: Amount,
    // Refund parameters for Fill or kill.
	pub refund_parameters: ChannelRefundParameters<Address>,
}

pub struct ChannelRefundParameters {
    // The number of blocks to wait before retrying swaps again.
	pub retry_duration: u32,
    // The address to refund assets to if the swaps failed to meet the `min_price`.
	pub refund_address: Address,
    // The minimum price the swap must meet.
	pub min_price: U256,
}
```
For specifications on `min_price: U256`, see [here](../../../../lp/integrations/lp-api.mdx#hex-price).

For an example on how to create this as part of the `broker_request_swap_parameter_encoding()` RPC call, see the section below.

### Example RPC call

#### Request the encoded payload via RPC

Below is an example of a RPC call that creates a Vault Swap request with CCM messages attached.

```bash copy 
curl -H "Content-Type: application/json" -d '{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "broker_request_swap_parameter_encoding",
    "params": [
        { "chain": "Ethereum", "asset": "ETH" },
    	{ "chain": "Ethereum", "asset": "FLIP" },
        "0xcf0871027a5f984403aEfD2fb22831D4bEBc11Ef",
        0,
        {
			"chain": "Ethereum",
			"input_amount": 1000,
			"refund_parameters": {
			    "retry_duration": 10,
			    "refund_address": "0xcf0871027a5f984403aEfD2fb22831D4bEBc11Ef",
			    "min_price": "0x0"
			}
		},
		{
			"message": "0x0011223344556677",
			"gas_budget": 1000,
			"ccm_additional_data": "0x"
		}
    ]
}' http://localhost:10997
```

#### Response from the RPC call

The response provides the following information:

| Field | Description | Type |
| ----- | ----------- | ---- |
| `calldata` | The constructed EVM transaction, already encoded. | `Vec<u8>` |
| `value` | The amount of native currency - (Eth for Ethereum or ArbEth or Arbitrum). 0 for ERC-20 tokens. | `U256` |
| `to` | Chainflip's Vault Smart Contract address for either Ethereum or Arbitrum. | `H160` address | 

Here is the example response from the RPC call above:

```json
{
  "jsonrpc": "2.0",
  "result": {
    "chain": "Ethereum",
    "calldata": "0x07933dd2000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000014cf0871027a5f984403aefd2fb22831d4bebc11ef00000000000000000000000000000000000000000000000000000000000000000000000000000000000000080011223344556677000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000a00000000cf0871027a5f984403aefd2fb22831d4bebc11ef000000000000000000000000000000000000000000000000000000000000000000009059e6d854b769a505d01148af212bf8cb7f8469a7153edce8dcaedd9d299125000000",
    "value": "0x3e8",
    "to": "0xb7a5bd0345ef1cc5e66bf61bdec17d2461fbd968"
  },
  "id": 1
}
```

### Sign and send EVM payload

The `cf_get_vault_swap_details` RPC call for EVM returns the data that will initiate a Vault swap via call to Chainflip's Vault smart contract. That contains the `data`, `value`, and `to` fields that shall be used to create and sign a transaction. Other values such as `gas` or `gasPrice` can be estimated and set by the user or wallet.

Here is an example in typescript using the `web3` library:

```typescript copy
import BigNumber from 'bignumber.js';
import Web3 from 'web3';

interface EvmVaultSwapDetails {
  chain: 'Ethereum' | 'Arbitrum';
  calldata: string;
  value: string;
  to: string;
}

const vaultSwapDetails = (await chainflip.rpc(
  `cf_get_vault_swap_details`,
    broker_address,
    source_asset,
    destination_asset,
    destination_address,
    broker_commission,
    extra_parameters,
    channel_metadata,
    boost_fee,
    affiliate_fees,
    dca_parameters,
)) as unknown as EvmVaultSwapDetails;

const web3 = new Web3("your-endpoint");
const tx = {
  to: vaultSwapDetails.to,
  data: vaultSwapDetails.calldata,
  value: new BigNumber(vaultSwapDetails.value.slice(2), 16).toString(),
};

// Send and sign using the preferred method, this is just a simple example
const signedTx = await web3.eth.accounts.signTransaction(tx, evmWallet.privateKey);
const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction as string);
```

## Vault contract interface references

The Vault smart contract can be called directly without using the provided RPCs to encode the transaction. Here is the reference for the Vault smart contract interface.

In the case of swapping ERC-20 tokens corresponding token **approval is required**.


```solidity
    // Swap native token
    function xSwapNative(
        uint32 dstChain,
        bytes calldata dstAddress,
        uint32 dstToken,
        bytes calldata cfParameters
    ) external payable;

    // Swap ERC20 token
    function xSwapToken(
        uint32 dstChain,
        bytes calldata dstAddress,
        uint32 dstToken,
        IERC20 srcToken,
        uint256 amount,
        bytes calldata cfParameters
    ) external;

    // Swap native token with CCM
    function xCallNative(
        uint32 dstChain,
        bytes calldata dstAddress,
        uint32 dstToken,
        bytes calldata message,
        uint256 gasAmount,
        bytes calldata cfParameters
    ) external payable;

    // Swap ERC20 token with CCM
    function xCallToken(
        uint32 dstChain,
        bytes calldata dstAddress,
        uint32 dstToken,
        bytes calldata message,
        uint256 gasAmount,
        IERC20 srcToken,
        uint256 amount,
        bytes calldata cfParameters
    ) external;
```

<Callout type="warning">
Chainflip's smart contract does some checks but it cannot check that all the parameters are valid and correctly encoded.
Incorrectly encoded parameters might **result in the loss of user funds**.

Therefore, it's adviced to use the RPC provided to craft Vault Swap. Otherwise make sure to thoroughly test your logic before initiating a swap with real funds.

</Callout>

### Parameter reference

| Param         | Description | Data Type |
| ------------- | ----------- | --------- |
| `dstChain`    | Destination [chain ID](./vault-swaps.mdx#supported-assets-and-chains) for the swap. | `uint32`   |
| `dstAddress`  | Address where the swapped tokens will be sent to on the destination chain. Addresses must be encoded into a bytes type valid for the destination chain. You can check out a reference on how to do address encoding for each of the chains from our [SDK](https://github.com/chainflip-io/chainflip-sdk-monorepo/blob/67d43db80d734a206dd2a0cc8334cb118c711906/packages/shared/src/vault/executeSwap.ts#L31). | `address` |
| `dstToken`    | Destination [token](../vault-swaps.mdx#supported-chains)| `u32` |
| `srcToken`    | Address of the token to be swapped from the source chain. | `address` |
| `amount`      | Amount of the source token to be swapped. When swapping a native asset, the `msg.value` passed in the call will be used instead. | `uint` |
| `cfParameters`| Additional metadata for additional features. See [here](./vault-swaps.mdx#chainflip-parameters-cf_parameters). | `bytes` |
| `message`   | Message that is passed to the destination address on the destination chain. It must be shorter than 15k bytes. | `bytes` |
| `gasAmount` | Gas budget for the call on the destination chain in gas units or compute units. This amount should cover the execution of the receiver's logic. | `uint` |