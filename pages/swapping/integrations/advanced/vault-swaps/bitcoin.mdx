---

title: Vault swaps for Bitcoin

description: Description of performing Vault Swaps for the Bitcoin network

---

import { Callout } from "@/components";

# Vault swaps for Bitcoin

## Overview

Bitcoin vault swaps are a way of initiating a swap by constructing a custom Bitcoin transaction that is sent to the Chainflip Vault via a private broker channel. 
The transaction contains all of the data needed to initiate the swap. Bitcoin vault swaps can be broken down into the following steps:

1. Open a [private channel](../../running-a-broker/broker-api.mdx#broker_open_private_btc_channel) (if not already open)
2. Request [swap parameter encoding](#example-rpc-call)
3. Use the encoded data and given deposit address to [create a custom Bitcoin transaction](#detailed-transaction-construction)
4. [Sign and broadcast](#example-for-signing-and-sending) the transaction on the Bitcoin network

<Callout type="warning">

Vault swaps with CCM attached for the Bitcoin network is currently not supported, due to limited transaction length. 

To avoid confusion, calling the `broker_request_swap_parameter_encoding()` RPC with CCM attached for Bitcoin will result in an error.

</Callout>

### Swap Parameter Encoding via Broker API

#### Bitcoin variant of `extra_parameters`

```rust
pub enum VaultSwapExtraParameters<Address, Amount> {
	Bitcoin {
        // Minimum output amount in the smallest unit of the output asset
		min_output_amount: Amount,
        // Number of blocks to wait before refunding the swap. Type: u32
		retry_duration: BlockNumber,
	},
	Ethereum(...),
	Arbitrum(...),
	Solana {...},
}
```

### Example RPC call

#### Request the encoded payload via RPC

```bash copy
curl -H "Content-Type: application/json" -d '{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "broker_request_swap_parameter_encoding",
    "params": [
        { "chain": "Bitcoin", "asset": "BTC" },
    	{ "chain": "Ethereum", "asset": "USDC" },
        "0xcf0871027a5f984403aEfD2fb22831D4bEBc11Ef",
        0,
        {
        	"chain": "Bitcoin",
			"min_output_amount": 1000000,
			"retry_duration": 10
		}
    ]
}' http://localhost:10997
```

### Response from the RPC call

Here is the example response from the RPC call above:

```json
{
  "jsonrpc": "2.0",
  "result": {
    "chain": "Bitcoin",
    "nulldata_payload": "0x0003cf0871027a5f984403aefd2fb22831d4bebc11ef0a0040420f0000000000000000000000000001000200000000",
    "deposit_address": "bcrt1pesng8qzx6wn7m2a5xq480mmtwcme964nx60f7sfpjha8n8lsup8s2vdvvf",
    "expires_at": 1736754672010
  },
  "id": 1
}
```

| Field | Description | Type |
| ----- | ----------- | ---- |
| `nulldata_payload` | The constructed Bitcoin transaction, already encoded. | `Vec<u8>` |
| `deposit_address` | The address the transaction is made to (the fund is deposited into). | Address |
| `expires_at` | Payload expiry time, expressed as timestamp since the UNIX_EPOCH in milliseconds | u64 | 

<Callout type="warning">
  The `expires_at` field is the Timestamp (since UNIX_EPOCH in milliseconds) at which the `deposit_address` will no longer be valid due to a vault rotation.

  This transaction **must be send before** the expiry time, or risk a loss of funds.
</Callout>

### Detailed Transaction Construction

The bitcoin transaction must have at least 3 outputs:
1) First output must be a deposit into a [private channel](../../running-a-broker/broker-api.mdx#broker_open_private_btc_channel).
2) Second output must be a `nulldata UTXO` with 0 amount containing the [encoded swap parameters](#example-rpc-call) in its ScriptPubKey.
3) Third output must be a `change UTXO` whose address is the refund address.

Example transaction:
```json
{
  "version": "01000000",
  "marker": "00",
  "flag": "01",
  "inputcount": "01",
  "inputs": [
    {
      "txid": "80bd605bd423b1916f1d4ac27d0143a9c7c472406fe97b29e5e5c3e96db52407",
      "vout": "03000000",
      "scriptsigsize": "00",
      "scriptsig": "",
      "sequence": "ffffffff"
    }
  ],
  "outputcount": "03",
  "outputs": [
    {
      "amount": "5796060000000000",
      "scriptpubkeysize": "19",
      "scriptpubkey": "76a914465d0a008517519ca75e70d35b31a199039fab9b88ac"
    },
    {
      "amount": "0",
      "scriptpubkeysize": "2E",
      "scriptpubkey": "6a2c01abababababababababababababababababababab0000e80300000000000000000000000000000100020000"
    },
    {
      "amount": "0",
      "scriptpubkeysize": "19",
      "scriptpubkey": "76a914d8f555940a44862e3cfb446fa3e4c38c2e57302388ac"
    }
  ],
  "locktime": "00000000"
}
```

### Reference for Encoding

You should not need to build this encoding yourself because you can use the [`broker_request_swap_parameter_encoding()` RPC](./vault-swaps.mdx) to encode the swap parameters.

The swap parameters are encoded in the `nulldata UTXO` ScriptPubKey. 
Please note that the refund address is part of the third output of the transaction (`change UTXO`). The encoding is done using the following order:

| Param | Description | Data Type |
| ------| ----------- | --------- |
| `version` | Encoding version number. Currently `0` | `u8` |
| `output_asset` | Destination [asset ID](./vault-swaps.mdx#supported-assets-and-chains). | `u8` |
| `output_address` | Encoded [address](../../running-a-broker/broker-api.mdx#addresses) | `bytes` |
| `retry_duration` | Number of blocks to wait before refunding the swap | `u16` |
| `min_output_amount` | Minimum output amount in the smallest unit of the output asset | `u128` |
| `number_of_chunks` | DCA: The number of "sub-swaps" to perform | `u16` |
| `chunk_interval` | DCA: The delay between dca chunks in number of blocks | `u16` |
| `boost_fee` | Maximum accepted boost fee in basis points (100th of a percent) | `u8` |
| `broker_fee` | Broker fee in basis points | `u8` |
| `affiliates` | List of up to 2 [affiliate short ID](../../running-a-broker/broker-api/#broker_register_affiliate) and fee (basis points) | `Vec<(u8, u8)>`|

<Callout type="info">
The encoded data in `nulldata_payload` returned by [broker_request_swap_parameter_encoding](../../running-a-broker/broker-api#broker_request_swap_parameter_encoding) does not include any OP codes. Depending on how you build your transaction, you may need to add these manually. 
First opcode must be `OP_RETURN` followed by either `OP_PUSHBYTES_X` (1..=75) or `OP_PUSHDATA1` (76).
</Callout>


## Example for Signing and Sending

```typescript copy
import Client from 'bitcoin-core';

const btcClient = new Client({
  host: 'your_btc_endpoint',
  port: 1234,
  username: 'your_username',
  password: 'your_password',
  wallet: 'your wallet',
});

interface BtcVaultSwapDetails {
  chain: string;
  nulldata_payload: string;
  deposit_address: string;
  expires_at: number;
}

// Get encoded swap details
const BtcVaultSwapDetails = (await chainflip.rpc(
  `cf_get_vault_swap_details`,
  brokerAddress,
  { chain: 'Bitcoin', asset: 'BTC' },
  { chain: destinationChain, asset: destinationAsset },
  destinationAddress,
  commissionBps,
  extraParameters,
  channelMetadata,
  boostFee,
  [{ account: affiliateAddress, bps: commissionBps }],
  dcaParams,
)) as unknown as BtcVaultSwapDetails;

// Create the transaction outputs
const outputs = [
  {
    [BtcVaultSwapDetails.deposit_address]: amountBtc,
  },
  {
    data: BtcVaultSwapDetails.nulldata_payload.replace('0x', ''),
  },
];

// Create, fund, sign and then broadcast the transaction
const rawTx = await btcClient.createRawTransaction([], outputs);
const fundedTx = (await btcClient.fundRawTransaction(rawTx, {
  changeAddress,
  feeRate: feeRate,
  changePosition: 2,
})) as { hex: string };
const signedTx = await btcClient.signRawTransactionWithWallet(fundedTx.hex);
const txId = (await btcClient.sendRawTransaction(signedTx.hex)) as string | undefined;

if (!txId) {
  throw new Error('Broadcast failed');
}
```