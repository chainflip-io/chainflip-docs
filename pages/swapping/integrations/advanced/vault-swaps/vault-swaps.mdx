---

title: Vault Swaps

description: How to use vault swaps for integration purposes.

---

import { Callout } from "@/components";

## Overview

Traditionally swaps initiated by brokers typically involves requesting an deposit address, then deposit fund into that deposit address to initiate the swap. This page introduces a new way to initiating swaps on the Chainflip network, where a direct call to the Chainflip Vault is used.

Vault swaps can be started without the use of [Deposit Channel/Addresses](../javascript-sdk/swap-assets/request-deposit-address/v2). Vault swaps support the same features as the swapps via deposit addresses.

<Callout type="info">
For more information, learn [How Swapping Works](../../how-swapping-works.mdx).
</Callout>

## Workflows

### Swap via Deposit Channels

1. Request a deposit channel via the `pallet_cf_swapping::request_swap_deposit_address_with_affiliates()` extrinsic. This can be done directly or via the `request_swap_deposit_address` RPC call from our Broker Api.

2. Deposit fund into the given deposit address.

3. Swaps are processed after deposits are witnessed by Chainflip Engine

### Vault swaps

1. Construct and submit a transaction on an external chain. This will be a smart contract call for EVM chains, a program call for Solana, or a particularly encoded transaction for Bitcoin.

2. This can be done by manually encoding the transaction (e.g. making the smart contract call) or by using the `request_swap_parameter_encoding` RPC call from our Broker Api. It's encouraged to use the broker API to ensure that the payloads are correctly encoded according to the specifications. Wrongly encoded payloads may result in lost of funds.

3. If using the Broker API, an encoded payload is obtained and must be signed and sent to the appropriate blockchain.

4. The transaction will transfer the appropriate funds to the Chainflip protocol as part of the smart contract call. Chainflip will then process the swap.


## Constructing a Vault Swap Transaction

Each of our supported chains encodes data differently. To make this feature easy to use, Chainflip provides the interface to build the transaction on the integrator's behalf. This way the transaction only needs to be signed and is then ready to be sent out to the perspective Vault contract.

The function that builds the encoded the transaction data is the [request_swap_parameter_encoding](../../running-a-broker/broker-api/#broker_request_swap_parameter_encoding) RPC call in the Broker Api.

<Callout type="info">
The function `request_swap_parameter_encoding()` looks very similar to `request_swap_deposit_address()`, but they are very different functions. 

`request_swap_deposit_address()` will submit an extrinsic that opens a deposit channels, and will return the deposit address.

`request_swap_parameter_encoding()` will **not** make any on-chain changes, but will instead build a transaction that will be returned.
</Callout>

### Example

An example RPC call is provided below. This call requests an Solana Transaction that swaps some Sol into Eth. 

<Callout type="info">
Each chain works a differently. Notice here for Solana, for example, the `input_amount` is required. This is not the case for some of other chains (such as Bitcoin). Please refer to the individual chain's page for more details.
</Callout>

```bash copy
curl -H "Content-Type: application/json" -d '{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "broker_request_swap_parameter_encoding",
    "params": [
    	{ "chain": "Solana", "asset": "SOL" },
        { "chain": "Ethereum", "asset": "ETH" },
        "0xc64722AD9613851b10E26fF8118A7696A0f956f2",
        0,
        {
            "chain": "Solana",
            "from": "BdyHK5DckpAFGcbZveGLPjjMEaADGfNeqcRXKoyd33kA",
            "event_data_account": "9acHwMGmeoMr5o8Cw1V2U4HjMQwhced3eQP31yYEhYDU",
            "input_amount": 1000000000,
            "refund_parameters": {
                "retry_duration": 10,
                "refund_address": "BdyHK5DckpAFGcbZveGLPjjMEaADGfNeqcRXKoyd33kA",
                "min_price": "0x0"
            }
        }
    ]
}' http://localhost:10997
```

The following response is received:
```json
{
  "jsonrpc": "2.0",
  "result": {
    "chain": "Solana",
    "program_id": "35uYgHdfZQT4kHkaaXQ6ZdCkK5LFrsk43btTLbGCRCNT",
    "accounts": [
      {
        "pubkey": "BttvFNSRKrkHugwDP6SpnBejCKKskHowJif1HGgBtTfG",
        "is_signer": false,
        "is_writable": false
      },
      {
        "pubkey": "BLS4cAizVv8V2fXYpKxr7RU1cqu4H4c97AovgQjDCQq2",
        "is_signer": false,
        "is_writable": true
      },
      {
        "pubkey": "BdyHK5DckpAFGcbZveGLPjjMEaADGfNeqcRXKoyd33kA",
        "is_signer": true,
        "is_writable": true
      },
      {
        "pubkey": "9acHwMGmeoMr5o8Cw1V2U4HjMQwhced3eQP31yYEhYDU",
        "is_signer": true,
        "is_writable": true
      },
      {
        "pubkey": "2tmtGLQcBd11BMiE9B1tAkQXwmPNgR79Meki2Eme4Ec9",
        "is_signer": false,
        "is_writable": true
      },
      {
        "pubkey": "11111111111111111111111111111111",
        "is_signer": false,
        "is_writable": false
      }
    ],
    "data": "0xa3265ce2f3698dc400ca9a3b000000000100000014000000c64722ad9613851b10e26ff8118a7696a0f956f201000000006b000000000a000000049e0d6a70e12d54edf90971cc977fa26a1d3bb4b0b26e72470171c36b0006b01f000000000000000000000000000000000000000000000000000000000000000000009059e6d854b769a505d01148af212bf8cb7f8469a7153edce8dcaedd9d299125000000"
  },
  "id": 1
}
```

<Callout type="info">
The transaction returned as result differs depending on the `source_asset`. The `chain` field will indicate the exact chain the transaction is built for. For the example above, since the source asset was Sol, the transaction built was for the Solana chain.
</Callout>

### Example with CCM

To request a vault Swap with [cross-chain messaging](../cross-chain-messaging/cross-chain-messaging.mdx) the `channel_metadata` field parameter must be filled. You can see an example below:

<Callout type="info">
Currently only Solana and EVM chains supports CCM. This means **CCM is only allows with vault swaps with `output asset` being on the Solana or EVM chain (such as Sol or ArbEth)**. The mechanism differs between Solana and EVM chains, please refer to [CCM support](../cross-chain-messaging/cross-chain-messaging.mdx) for more details.
</Callout>

```sh
curl -H "Content-Type: application/json" -d '{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "broker_request_swap_parameter_encoding",
    "params": [
		{ "chain": "Solana", "asset": "SOL" },
        { "chain": "Ethereum", "asset": "ETH" },
        "0xc64722AD9613851b10E26fF8118A7696A0f956f2",
        0,
        {
            "chain": "Solana",
            "from": "BdyHK5DckpAFGcbZveGLPjjMEaADGfNeqcRXKoyd33kA",
            "event_data_account": "9acHwMGmeoMr5o8Cw1V2U4HjMQwhced3eQP31yYEhYDU",
            "input_amount": 1000000000,
            "refund_parameters": {
                "retry_duration": 10,
                "refund_address": "BdyHK5DckpAFGcbZveGLPjjMEaADGfNeqcRXKoyd33kA",
                "min_price": "0x0"
            }
        },
        {
          "message": "0x0011223344556677",
          "gas_budget": 1000,
          "ccm_additional_data": "0x"
        }
    ]
}' http://localhost:10997
```

### Construct, sign and and broadcast a transaction

With the payload encoded, the next step is construct a transaction from that payload and sent to the correct chain's Vault contract address. This step differs for each chain/asset. Please refer to the page dedicated for each chain for more details and other information.

<Callout type="info">
The chain you need to interact with depends on the `Input/Source asset`. 
e.g. if you are swapping Eth into Bitcoin, you should check out the page dedicated to Ethereum and Arbitrum.
</Callout>

[For Bitcoin network](./bitcoin.mdx)

[For Ethereum and Arbitrum](./evm.mdx)

[For Solana](./solana.mdx)

---


### References

#### Input parameters

| Parameter | Description | Data Type |
|-----------|-------------|-----------|
| source_asset | Input asset for the swap | `Asset` |
| destination_asset | Output asset for the swap | `Asset` |
| destination_address | Destination address the swap is paid out to | `AddressString` |
| broker_commission | Broker commission in Basis point | `u16` |
| extra_parameters | Chain specific extra parameters. For details see each chain's dedicated page | `VaultSwapExtraParametersRpc` |
| channel_metadata | Optional: Information for CCM | `Option<CcmChannelMetadata>` |
| boost_fee | Optional: Boost fee for the swap ingress  | `Option<u16>` |
| affiliate_fees | Optional: A list of affiliates and their fees | `Option<Affiliates<AccountId32>>` |
| dca_parameters | Optional: Parameters for Dca swaps | `Option<DcaParameters>` |


#### Type References 

The following are references for the Types used in Vault Swap calls. This can be used for references when building your RPC call.

```rust
/// For CCM message
pub struct CcmChannelMetadata {
	/// A Vec of bytes with maximum length of 15_000. `BoundedVec<u8, ConstU32<15_000>>`
	pub message: CcmMessage,
	/// User funds designated to be used for gas.
	pub gas_budget: GasAmount,
	/// Additional parameters for the cross chain message. Only used for Solana CCMs 
	/// A Vec of bytes with maximum length of 1_000. `BoundedVec<u8, ConstU32<1_000>>`
	pub ccm_additional_data: CcmAdditionalData,
}

/// Bounded vec of affiliates and fees in Basis Points. Max size of 5
pub type Affiliates<Id> = BoundedVec<Beneficiary<Id>, ConstU32<MAX_AFFILIATES>>;

pub struct Beneficiary<Id> {
	pub account: Id,
	pub bps: u16,
}

/// Parameters for DCA
pub struct DcaParameters {
	/// The number of individual swaps to be executed
	pub number_of_chunks: u32,
	/// The interval in blocks between each swap.
	pub chunk_interval: u32,
}
```

#### Supported Chain and Asset Notation

Chainflip uses it's own notation for chain and token within our Vault smart contracts. These are the values for the source and destination chains and assets parameters described above. The same values apply for the the corresponding testnets (e.g. Ethereum mainnet and Sepolia share the same value).

| Asset   | Chain      |  Asset ID  |   | Chain      | Chain ID |
| ------- | ---------- |  --------  | - | ---------- |  ------- |
| ETH     | Ethereum   |  1         |   | Ethereum   | 1        |
| FLIP    | Ethereum   |  2         |   | Polkadot   | 2        |
| USDC    | Ethereum   |  3         |   | Bitcoin    | 3        |
| DOT     | Polkadot   |  4         |   | Arbitrum   | 4        |
| BTC     | Bitcoin    |  5         |   | Solana     | 5        |
| arbETH  | Arbitrum   |  6         |   |            |          |
| arbUSDC | Arbitrum   |  7         |   |            |          |
| USDT    | Ethereum   |  8         |   |            |          |
| SOL     | Solana     |  9         |   |            |          |
| solUSDC | Solana     |  10        |   |            |          |



---

#### Chainflip parameters (`cf_parameters`)

<Callout type="info">
This section is only relevant if you want to encode EVM and Solana Vault swap transactions manually instead of using the provided RPC helpers.
If you use the `broker_request_swap_parameter_encoding` RPC call to build the call, this field is automatically encoded for you. 
</Callout>

As described in the [EVM smart contract interface](./evm.mdx#vault-contract-interface-references) and  the [Solana program interface](./solana.mdx#parameter-reference-for-the-program-call), the `cf_parameters` must be passed as part of the transaction data. The protocol expects a `VersionedCfParameters` encoded into bytes format using Parity's Scale.

```rust 
#[derive(Encode, Decode)]
pub enum VersionedCfParameters<CcmData = ()> {
	V0(CfParameters<CcmData>),
}

/// By default, the CfParameters do not contain CCM message. Therefore the CcmData is the () type.
#[derive(Encode, Decode, MaxEncodedLen, TypeInfo, Clone, PartialEq, Debug)]
pub struct CfParameters<CcmData = ()> {
	/// CCMs may require additional data (e.g. CCMs to Solana requires a list of addresses).
	pub ccm_additional_data: CcmData,
	pub vault_swap_parameters: VaultSwapParameters,
}

/// If CCM is included as part of the Vault Swap, additional data should be included here.
/// Additional data is Byte array with a maximum size of 1_000. See below for more details.
pub type VersionedCcmCfParameters = VersionedCfParameters<CcmAdditionalData>;
pub type CcmAdditionalData = BoundedVec<u8, ConstU32<1_000>>;

#[derive(Encode, Decode, MaxEncodedLen, TypeInfo, Clone, PartialEq, Debug)]
pub struct VaultSwapParameters {
  // Refund parameter, using Chainflip's internal `ForeignChainAddress` address format.
	pub refund_params: ChannelRefundParametersDecoded,
  // DCA parameters. See Vault Swaps page for its type reference.
	pub dca_params: Option<DcaParameters>,
	pub boost_fee: u8,
  // List of accounts and amount of fees to pay to (in BasisPoint)
	pub broker_fee: Beneficiary<AccountId>,
  // List of Affiliates to pay fees to.
	pub affiliate_fees: BoundedVec<AffiliateAndFee, ConstU32<5>>,
}
```

Here is an encoding example of the `cf_parameters` in typescript using the `scale-ts` library and some other utility functions from some other libraries. Those dependencies will be needed in your `package.json` file.

```typescript

import { bytesToHex, hexToBytes } from '@chainflip/utils/bytes';
import * as ss58 from '@chainflip/utils/ss58';
import { isHex } from '@chainflip/utils/string';
import { u32, Struct, Option, u16, u256, Bytes as TsBytes, Enum, Vector, u8 } from 'scale-ts';

const vaultSwapParametersCodec = Struct({
  refundParams: Struct({
    retryDurationBlocks: u32,
    refundAddress: Enum({
      Ethereum: TsBytes(20),
      Polkadot: TsBytes(32),
      Bitcoin: TsBytes(),
      Arbitrum: TsBytes(20),
      Solana: TsBytes(32),
    }),
    minPriceX128: u256,
  }),
  dcaParams: Option(Struct({ numberOfChunks: u32, chunkIntervalBlocks: u32 })),
  boostFee: u8,
  brokerFees: Struct({ account: TsBytes(32), commissionBps: u16 }),
  affiliateFees: Vector(Struct({ account: u8, commissionBps: u8 })),
});

const vaultCcmCfParametersCodec = Enum({
  V0: Struct({
    ccmAdditionalData: TsBytes(),
    vaultSwapParameters: vaultSwapParametersCodec,
  }),
});

const vaultCfParametersCodec = Enum({
  V0: Struct({
    vaultSwapParameters: vaultSwapParametersCodec,
  }),
});

function encodeCfParameters(
  sourceChain: 'Bitcoin' | 'Ethereum' | 'Polkadot' | 'Arbitrum' | 'Solana',
  fillOrKillParams: {
    retryDurationBlocks: number;
    refundAddress: string;
    minPriceX128: string;
  },
  brokerFees: {
    account: string;
    commissionBps: number;
  },
  ccmAdditionalData?: string | undefined,
  boostFeeBps?: number,
  dcaParams?: {
    numberOfChunks: number;
    chunkIntervalBlocks: number;
  },
  affiliateFees?: {
    account: number;
    commissionBps: number;
  }[],
): string {
  const vaultSwapParameters = {
    refundParams: {
      retryDurationBlocks: fillOrKillParams.retryDurationBlocks,
      refundAddress: {
        tag: sourceChain,
        value: hexToBytes(fillOrKillParams.refundAddress as `0x${string}`),
      },
      minPriceX128: BigInt(fillOrKillParams.minPriceX128),
    },
    dcaParams,
    boostFee: boostFeeBps ?? 0,
    brokerFees: {
      account: isHex(brokerFees.account)
        ? hexToBytes(brokerFees.account)
        : ss58.decode(brokerFees.account).data,
      commissionBps: brokerFees.commissionBps,
    },
    affiliateFees: affiliateFees ?? [],
  };

  return bytesToHex(
    ccmAdditionalData !== undefined
      ? vaultCcmCfParametersCodec.enc({
          tag: 'V0',
          value: {
            ccmAdditionalData: hexToBytes(ccmAdditionalData as `0x${string}`),
            vaultSwapParameters,
          },
        })
      : vaultCfParametersCodec.enc({
          tag: 'V0',
          value: {
            vaultSwapParameters,
          },
        }),
  );
}

```

