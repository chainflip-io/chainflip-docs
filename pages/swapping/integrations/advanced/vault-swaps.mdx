---

title: Vault Swaps

description: How to use vault swaps for integration purposes.

---

import { Callout } from "@/components";

## EVM contract integration

### Overview

The Vault smart contract, besides holding assets, acts as an entry point for starting a swap without requiring a [deposit address](../javascript-sdk/swap-assets/request-deposit-address/v2). Furthermore, for cross-chain messaging swaps, the Vault will call the destination address with a particular function signature.

<Callout type="info">
For more information, learn [How Swapping Works](../../how-swapping-works.mdx).
</Callout>

### Initiate simple swap

To make a swap the user needs to call swap on the Vault of the source chain, specifying the parameters described in the table below. In the case of swapping ERC-20 tokens an **approval is required**.

| Param         | Description                                                                                                     | Data Type  |
|---------------|-----------------------------------------------------------------------------------------------------------------|------------|
| `dstChain`    | Destination chain for the swap                                                                                  | `uint32`   |
| `dstAddress`  |  Address where the swapped tokens will be sent to on the destination
        chain. Addresses must be encoded into a bytes type valid for the destination chain.
        You can check out a reference on how to do address encoding for each of the chains
        from our [SDK](https://github.com/chainflip-io/chainflip-sdk-monorepo/blob/67d43db80d734a206dd2a0cc8334cb118c711906/packages/shared/src/vault/executeSwap.ts#L31) | `address`  |
| `dstToken`    | Token to be received on the destination chain                                                                   | `uint32`   |
| `srcToken`    | Address of the token to be swapped from the source chain                                                        | `address`  |
| `amount`      | Amount of the source token to be swapped. When swapping a native asset, the `msg.value` passed in the call will be used instead. | `uint`     |
| `cfParameters`| Additional metadata for future features. Currently unused.                                                      | `bytes`    |


```solidity
    // Swap native token
    function xSwapNative(
        uint32 dstChain,
        bytes calldata dstAddress,
        uint32 dstToken,
        bytes calldata cfParameters
    ) external payable;

    // Swap ERC20 token
    function xSwapToken(
        uint32 dstChain,
        bytes calldata dstAddress,
        uint32 dstToken,
        IERC20 srcToken,
        uint256 amount,
        bytes calldata cfParameters
    ) external;
```

### Initiate swap with call to a receiver with cross-chain messaging (CCM)

Chainflip supports cross-chain messaging, calling a smart contract on the destination chain and passing a message between chains. The smart contract call looks very similar to the previous ones but with some added parameters.

For more information see [Cross-Chain Messaging](cross-chain-messaging/cross-chain-messaging.mdx). The swap could have originated in any supported chain, irrespective of whether the chain supports smart contracts.

<Callout type="warning">

Invalid parameters may lead to loss of funds. Make sure all parameters are correct, supported and follow the Chainflip protocol's nomenclature since reverting a transaction is not guaranteed.

</Callout>

| Param       | Description                                                                                                                   | Data Type  |
|-------------|-------------------------------------------------------------------------------------------------------------------------------|------------|
| `message`   | Message that is passed to the destination address on the destination chain. It must be shorter than 10k bytes.                | `bytes`    |
| `gasBudget` | Gas budget for the call on the destination chain. This amount is based on the source asset and will be subtracted from the input amount and swapped to pay for gas. | `uint`     |


```solidity
    // Swap native token
    function xCallNative(
        uint32 dstChain,
        bytes calldata dstAddress,
        uint32 dstToken,
        bytes calldata message,
        uint256 gasAmount,
        bytes calldata cfParameters
    ) external payable;

    // Swap ERC20 token
    function xCallToken(
        uint32 dstChain,
        bytes calldata dstAddress,
        uint32 dstToken,
        bytes calldata message,
        uint256 gasAmount,
        IERC20 srcToken,
        uint256 amount,
        bytes calldata cfParameters
    ) external;
```

### Receive call and asset on the receiver contract (CCM)

Chainflip's Vault will transfer the destination token amount to the specified address either within the same call (for native token) or by transfering the ERC20 token to it. Then it will call the destination address with the following parameters:

| Param       | Description                                                                                       | Data Type  |
|-------------|---------------------------------------------------------------------------------------------------|------------|
| `srcChain`  | Source chain for the swap                                                                         | `uint32`   |
| `srcAddress`| Address that initiated the swap on the source chain. Addresses are encoded into a bytes type      | `address`  |
| `message`   | Message that is passed to the destination address on the destination chain.                       | `bytes`    |
| `token`     | Address of the token transferred to the receiver. A value of `0xEeee...eeEEeE` represents the native token. | `address`  |
| `amount`    | Amount of the destination token transferred to the receiver. If it's the native token, the amount value will equal the `msg.value`. | `uint`     |

In order for a contract to be a valid receiver it **must implement the Solidity function signature** below on the destination address.

```solidity
function cfReceive(
    uint32 srcChain,
    bytes calldata srcAddress,
    bytes calldata message,
    address token,
    uint256 amount
) external payable;
```

It's the receiver's responsability to correctly implement the function's interface and to ensure the call doesn't revert. If the receiver can't garantee that the receiving logic won't revert, it is recommended to use try/catch-like structure to handle the reversion. This is to avoid the full transaction reverting and therefore the tokens failing to be transferred.

<Callout>
<span style={{color: 'red', fontWeight: 'bold'}}>IMPORTANT!</span>
Chainflip will transfer tokens to the receiver and then make the call. For ERC-20 tokens, the logic has to assume the amount has been transferred. An attacker could call this function and fake the transfer, exploiting the receiver.
We strongly suggest that only the Chainflip Vault can call your function, unless you're transferring all tokens out of the receiver in the same call (like DEX Aggregators).

</Callout>
Here is an example of the function with the adequate access control:

```solidity
contract CFReceiver {

    function cfReceive(
        uint32 srcChain,
        bytes calldata srcAddress,
        bytes calldata message,
        address token,
        uint256 amount
    ) external payable {
        require(msg.sender == cfVault, "CFReceiver: caller not CF Vault");
    }

    ...
}
```

You can find an example of an implementation of a receiver contract with the mentioned interface [here](https://github.com/chainflip-io/chainflip-eth-contracts/blob/master/contracts/abstract/CFReceiver.sol). The contract also has other logic that is not necesary like the `cfReceivexCall` (currently unsupported) or the logic to update the `cfVault` address.

<Callout type="warning">

If the receiver is not a contract, doesn't have the specified interface or the logic in the receiver reverts, the Chainflip protocol will not submit the transaction to the destination chain. This may result in a loss of funds.

</Callout>

## Bitcoin

### Transaction Construction

The bitcoin transaction must have at least 3 outputs:
1) First output must be a deposit into the Chainflip vault.
2) Second output must be a `nulldata UTXO` with 0 amount containing the encoded swap parameters in its ScriptPubKey.
3) Third output must be a `change UTXO` whose address is the refund address.

Example:
```json
{
  "version": "01000000",
  "marker": "00",
  "flag": "01",
  "inputcount": "01",
  "inputs": [
    {
      "txid": "80bd605bd423b1916f1d4ac27d0143a9c7c472406fe97b29e5e5c3e96db52407",
      "vout": "03000000",
      "scriptsigsize": "00",
      "scriptsig": "",
      "sequence": "ffffffff"
    }
  ],
  "outputcount": "03",
  "outputs": [
    {
      "amount": "5796060000000000",
      "scriptpubkeysize": "19",
      "scriptpubkey": "76a914465d0a008517519ca75e70d35b31a199039fab9b88ac"
    },
    {
      "amount": "0",
      "scriptpubkeysize": "2E",
      "scriptpubkey": "6a2c01abababababababababababababababababababab0000e80300000000000000000000000000000100020000"
    },
    {
      "amount": "0",
      "scriptpubkeysize": "19",
      "scriptpubkey": "76a914d8f555940a44862e3cfb446fa3e4c38c2e57302388ac"
    }
  ],
  "locktime": "00000000"
}
```

Once the transaction is constructed, it must be signed and broadcasted to the Bitcoin network.

### Encoding

You can use the [broker_request_swap_parameter_encoding](../running-a-broker/broker-api#broker_request_swap_parameter_encoding) RPC to encode the swap parameters.
The swap parameters are encoded in the `nulldata UTXO` ScriptPubKey. The encoding is done using the following order:

| Param | Description | Data Type |
| ------| ----------- | --------- |
| `output_asset` | Destination asset ID, represented by [Chainflip's internal asset notation](vault-swaps/#supported-assets) | `u8` |
| `output_address` | Encoded address | `bytes` |
| `retry_duration` | Number of blocks to wait before refunding the swap | `u16` |
| `min_output_amount` | Minimum output amount in the smallest unit of the output asset | `u128` |
| `number_of_chunks` | DCA: The number of "sub-swaps" to perform | `u16` |
| `chunk_interval` | DCA: The delay between dca chunks in number of blocks | `u16` |
| `boost_fee` | Maximum accepted boost fee in basis points (100th of a percent) | `u8` |


## Chain and Asset Notation

Chainflip uses it's own notation for chain and token within the the smart contracts. These are the values for the source and destination chains and assets parameters described above. The same values apply for the the corresponding testnets (e.g. Ethereum mainnet and Sepolia share the same value).

### Supported Assets

| Asset   | ID |
| ------- | -- |
| ETH     | 1  |
| FLIP    | 2  |
| USDC    | 3  |
| DOT     | 4  |
| BTC     | 5  |
| arbETH  | 6  |
| arbUSDC | 7  |
| USDT    | 8  |
| SOL     | 9  |
| solUSDC | 10  |

### Supported Chains

| Chain      | ID |
| ---------- | -- |
| Ethereum   | 1  |
| Polkadot   | 2  |
| Bitcoin    | 3  |
| Arbitrum   | 4  |
| Solana     | 5  |
