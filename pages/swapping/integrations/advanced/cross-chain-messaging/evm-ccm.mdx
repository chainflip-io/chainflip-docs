---

title: CCM Swaps to EVM

description: Description of CCM swaps to EVM chains.

---

import { Callout } from "@/components";

# CCM Swaps to EVM Chains

## EVM Considerations

Besides the general [implementation checklist](cross-chain-messaging#implementation-checklist), there are some specific considerations for EVM chains.
- The gas limit on the destination chain (EVM) will be capped to 10 million gas.
- The receiver contract on the destination chain must implement the `cfReceive` function specified in the [EVM integration](../vault-swaps#receive-call-and-asset-on-the-receiver-contract-ccm).
- If the amount of gas provided is not enough to cover the gas costs of the receiver's logic on the destination chain, the transaction won't be broadcasted. An example of a gas estimation is provided [below](#gas-budget-estimation).
- In the event of a transaction not being broadcasted due to insufficient gas, the signed payload will be available for the user to broadcast as described [here](#ccm-broadcast-failure).

## Gas budget estimation

The gas budget represents the amount of gas required by the user logic on the destination chain. The Chainflip protocol will automatically add the gas requirements for the overhead of the on-chain transaction verification and call.

The simplest way to estimate the gas needed on the destination chain is to simulate the execution of the receiver's logic with a direct call to the receiver contract with the parameters expected from the Chainflip call. The base 21k gas can be substracted as it will automatically be added by the protocol as part of the overhead.

An overestimation, `overestimationRatio`, is advised due to the not fully predictable nature of gas usage in EVM as well as to avoid transactions running out of gas. Currently Chainflip does not issue refunds of unspent gas.

```typescript copy
import Web3 from 'web3';

const web3 = new Web3('your-endpoint');

const EVM_BASE_GAS_LIMIT = 21000;
// Use any framework you want (Brownie, Forge etc..) to estimate instead.
// In this example just using ABI encoded data call to `cfReceive` with the CCM message, srcChain...
const data = '0x4904ac5f0000...';
// Estimate needs to be done using "from: vault" to prevent logic revertion
const userGasEstimation = (await web3.eth.estimateGas({ data, to: usersReceiverContractAddress, from: ChainflipVaultAddress})) - EVM_BASE_GAS_LIMIT;
const overestimationRatio = 1.1;
const gasBudget = userGasEstimation * overestimationRatio;
```


<Callout type="info">
Arbitrum uses the same `eth_estimateGas` for gas estimations as described in [Arbitrum How to estimate L2 gas](https://docs.arbitrum.io/how-arbitrum-works/gas-fees#estimating-l2-gas). However, the transaction gas cost changes depend on multiple factors such as the L1 fees, as explained in the [Arbitrum Docs](https://docs.arbitrum.io/build-decentralized-apps/how-to-estimate-gas). 

Therefore it's recommended to always run a gas estimation and not rely on old estimations for similar transactions. It's also advised to use a higher overestimation ratio for Arbitrum gas budget calculations for this reason.
</Callout>

###  Gas budget estimation example

- User wants to swap BTC to FLIP, destination chain being Ethereum, with a CCM call to a receiver contract.
- Estimate of the gas needed to execute the receiver's logic on the destination chain with the corresponding message to be passed via `eth_estimateGas`
- Apply the desired overestimation ratio,
- Start a swap in Chainflip with the calculated `gasBudget` amount.

## BTC to ETH (Ethereum) Example

1. A user has `BTC` on the Bitcoin blockchain and wants to swap it to `ETH` on Ethereum blockchain and then **execute some logic on a smart contract**.
2. The user requests a bitcoin deposit address as described [here](../../javascript-sdk/swap-assets/request-deposit-address/v2.md#ccmparams-cross-chain-messaging-ccm) (only when the source chain is EVM-compatible, this can be initiated via a smart contract call).
3. The user defines, as part of requesting a deposit adddress, two additional parameters: `message` and `gasBudget`. **The `message` can be an arbitrary HEX-encoded sequence of bytes**.
4. The user transfers an amount to swap.
5. Chainflip will swaps the input amount to the destination asset ('ETH'). It will then estimate how much gas the transaction needs taking into account the transaction overhead and the user's gas budget.
6. The Chainflip protocol will then substract from the final amount the native asset amount needed to pay for the gas costs of the transaction on the destination chain.
6. After the threshold signature is completed, a transaction originating from the Vault contract transfers the destination asset to the specified receiver address, on the destination chain, and makes a call to that address with a specific interface passing the user's `message`. The gas limit on that call is set according to the `gasBudget` swap output and the current gas price.
7. The receiver contract executes its logic, which can entail decoding the received `message` from the source chain and execute logic accordingly, i.e. swap `ETH` into `<any-long-tail-asset>` in a Uniswap pool.


## CCM broadcast failure

While Chainflip will do it's best to broadcast and succesfully execute any swap with cross-chain messaging, there are some factors that can make the swap fail that are external to Chainflip. Here are some examples.

- The gas budget provided is not enough to cover the gas costs of the receiver's logic on the destination chain.
- The receiver contract not implementing the correct interface (or being an EOA).
- The logic executed on the receiver's contract reverts.

Chainflip will use TSS to sign over a valid payload for the destination chain and try to broadcast it. If a transaction can't be broadcasted for any reason, the signed payload will be publicly accessible on the Chainflip State Chain for the user. The user can then sign over the payload and broadcast the transaction.

If the transaction reverts due to not enough gas, the user can sign that payload and broadcast it with a higher amount of gas. If it's due to the receiving logic reverting, the user can try to modify the state of the receiving contract before broadcasting it again. The payload will be valid until two key rotations have taken place.

Below you can find a very simple example on how to broadcast a signed payload that has failed to broadcast due to insufficient gas. It users ethers `sendTransaction` to automatically estimate the required gas, send it and broadcast it.


```typescript copy
import { ethers, Wallet } from "ethers";

const connection = new ethers.JsonRpcProvider(<your-rpc-provider>);
const wallet = new Wallet(<your-keys>);
const signer = wallet.connect(connection);
const tx = {
    from:  wallet.address,
    to:    "<signed-transaction-payload-contract>", // "0x..."
    value: ethers.parseUnits('0', 'ether'),
    data:  "<signed-transaction-payload-data>"      // "0x..."
};

await signer.sendTransaction(tx);
```

You will find the "Signed transaction payload" in the Swaps page as part of the Broacast Status. Only the `contract`, `data` and `value` fields are needed.

![Signed Transaction Payload](./signed_transaction_payload.png)

<Callout type="warning">
The signed payload can be broadcasted with different gas settings but it can't modify any value in that payload (data) such as the message. Therefore, always make sure to test the receiving logic and ensure it won't revert before initiating a swap.
</Callout>
