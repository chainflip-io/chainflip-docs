---

title: Solana Vault Swaps

description: Description of the Solana Vault swaps for integration purposes.

---

import { Callout } from "@/components";

# Solana Vault swaps

Solana swaps are transactions that interact directly with Chainflip's Solana program, the SwapEndpoint. Such transaction will be witnessed and will intiate a swap directly on the Chainflip's State Chain.

To ensure the correctness and the data availability of the Vault swap metadata, such data is stored on-chain (Solana) until the swap is processed by the Chainflip protocol. That means that the Vault swap transaction requires the creation of a new account, called Swap Event account, where the data will be stored. Therefore, the generation of a new keypair is required to sign the transaction and create the new account with the data.

The user will incurr in some fees to create the account, also known as rent in the Solana blockchain. The rent is the amount of SOL required to store the data on-chain for a certain period of time. Once the swap is processed the Chainflip protocol will automatically close the account and return the full rent to the user.

The newly created keypair will be used to sign the transaction and create the new account with the data. The user will also need to sign the transaction to initiate the swap. Once the account is created the keypair can be discarded. It's highly recommended to not reuse the keypair for future Vault swaps.

# Swap Endpoint program interface

The Anchor IDL for the SwapEndpoint can be found on-chain at: [TODO: Anchor IDL link](https://solexplorer.solana.com/address/TODO)

The IDL can be used to make program calls to the SwapEndpoint program on Solana. The relevant functions for the Vault swaps are `xSwapNative` and `xSwapToken` for native SOL or for SPL-tokens respectively. However, some of the parameters are not static (e.g. `aggKey`), which makes the manual crafting of these transactions a bit more complex.

These dynamic values can be read from either the State Chain or Solana itself, since they are all stored on-chain. For easier integration the user can use the Broker API to get the instruction to call the SwapEndpoint program. That will return the correct encoded data so the only step left is to send and sign the transaction.

## Using the Broker API

TODO: Some RPC parameters are common and can be described in a common file. To agree where the chain specific will be described,
if in this page or also as part of the other file.

The `cf_get_vault_swap_details` RPC call returns the instruction that will initiate a Vault swap. As per a regular Solana instruction, it contains:

- **ProgramId**: The address of the Chainflip's Solana program to call.
- **Accounts**: The accounts required to execute the instruction.
- **Data**: The instruction data to send to the program.

These are the three parameters from an instruction that shall be included in a Solana instruction. The instruction will make the adequate call to the SwapEndpoint program. In can be used in combination with other instructions in the same transaction.

Below you can find an example of how to create Solana transaction with the vault swap instruction using the Solana web3.js library.


```typescript copy
import {
  PublicKey,
  Keypair,
  sendAndConfirmTransaction,
  TransactionInstruction,
  Transaction,
  AccountMeta,
} from '@solana/web3.js';

interface SolVaultSwapDetails {
  chain: string;
  program_id: string;
  accounts: RpcAccountMeta[];
  data: string;
}

type RpcAccountMeta = {
  pubkey: string;
  is_signer: boolean;
  is_writable: boolean;
};

interface SolanaVaultSwapExtraParameters {
  chain: 'Solana';
  from: string;
  event_data_account: string;
  input_amount: string;
  refund_parameters: ChannelRefundParameters;
  from_token_account?: string;
}

// Generate a new keypair for the new event account
const newEventAccountKeypair = Keypair.generate();

const vaultSwapDetails = (await chainflip.rpc(
  `cf_get_vault_swap_details`,
    broker_address,
    source_asset,
    destination_asset,
    destination_address,
    broker_commission,
    extra_parameters,
    channel_metadata,
    boost_fee,
    affiliate_fees,
    dca_parameters,
)) as unknown as SolVaultSwapDetails;

// Convert vaultSwapDetails.instruction.accounts into web3.AccountMeta[]
const keys: AccountMeta[] = [];
for (const account of vaultSwapDetails.accounts) {
  keys.push({
    pubkey: new PublicKey(account.pubkey),
    isSigner: account.is_signer,
    isWritable: account.is_writable,
  });
}

const transaction = new Transaction();
const instruction = new TransactionInstruction({
  keys,
  programId: new PublicKey(vaultSwapDetails.program_id),
  data: Buffer.from(vaultSwapDetails.data.slice(2), 'hex'),
});

transaction.add(instruction);

await sendAndConfirmTransaction(
  connection,
  transaction,
  [userKeypair, newEventAccountKeypair]
);
```

## Two step signing


It might be useful to separately sign with the `newEventAccountKeypair` and the user keypair. For exampleto craft a transaction that the final user signs in his wallet and broadcasts automatically, we need to provide a partially signed transaction.
To do that we can use the following code instead of `sendAndConfirmTransaction`:

```typescript copy
  transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
  // First set the feePayer to the whale keypair to sign the transaction. Otherwise
  // by default the first signer will be the feePayer.
  transaction.feePayer = whaleKeypair.publicKey;
  transaction.partialSign(newEventAccountKeypair);
  transaction.partialSign(whaleKeypair);
  await connection.sendRawTransaction(transaction.serialize());
  await connection.confirmTransaction(txHash);
  ```

## Manually encoded program call

Using the Anchor framework with the interface mentioned above it's easy to call the program directly. Below is an example for native and token swaps.

```typescript copy
import * as anchor from '@coral-xyz/anchor';
import {SystemProgram, Keypair, Transaction} from '@solana/web3.js';

// Generate a new keypair for the new event account
const newEventAccountKeypair = Keypair.generate();
const tx = cfSwapEndpointProgram.methods
    .xSwapNative({
      amount,
      dstChain,
      dstAddress,
      dstToken,
      ccmParameters,
      cfParameters,
    })
    .accountsPartial({
      dataAccount,
      aggKey,
      from,
      eventDataAccount,
      swapEndpointDataAccount,
      systemProgram,
    })
    .signers([userKeypair, newEventAccountKeypair])
    .transaction();
await sendAndConfirmTransaction(connection, tx, [userKeypair, newEventAccountKeypair]);
```

```typescript copy
import * as anchor from '@coral-xyz/anchor';
import {SystemProgram, Keypair, Transaction} from '@solana/web3.js';

// Generate a new keypair for the new event account
const newEventAccountKeypair = Keypair.generate();
const tx = cfSwapEndpointProgram.methods
    .xSwapToken({
      amount,
      dstChain,
      dstAddress,
      dstToken,
      ccmParameters,
      cfParameters,
      decimals
    })
    .accountsPartial({
      dataAccount,
      tokenVaultAssociatedTokenAccount,
      from,
      fromTokenAccount,
      eventDataAccount,
      swapEndpointDataAccount,
      tokenSupportedAccount,
      tokenProgram,
      mint,
      systemProgram,
    })
    .signers([userKeypair, newEventAccountKeypair])
    .transaction();
await sendAndConfirmTransaction(connection, tx, [userKeypair, newEventAccountKeypair]);
```

TODO: Add links to some common place where the values of these parameters are described. Currently in EVM vault-swaps but they should be somewhere common.


{<table>
  <thead>
    <tr>
      <th width="223">Param</th>
      <th width="371">Description</th>
      <th width="244.33333333333331">Data type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <code>amount</code>
      </td>
      <td>Amount of the source token to be swapped</td>
      <td><code>u64</code></td>
    </tr>
    <tr>
      <td>
        <code>dstChain</code>
      </td>
      <td>Destination chain for the swap</td>
      <td><code>u32</code></td>
    </tr>
    <tr>
      <td>
        <code>dstAddress</code>
      </td>
      <td>
        Address where the swapped tokens will be sent to on the destination
        chain. Addresses must be encoded into a bytes type valid for the destination chain.
        You can check out a reference on how to do address encoding for each of the chains
        from our <a href="https://github.com/chainflip-io/chainflip-sdk-monorepo/blob/67d43db80d734a206dd2a0cc8334cb118c711906/packages/shared/src/vault/executeSwap.ts#L31">SDK</a>.
      </td>
      <td><code>Vec&lt;u8&gt;</code></td>
    </tr>
    <tr>
      <td>
        <code>dstToken</code>
      </td>
      <td>Token to be received on the destination chain</td>
      <td><code>u32</code></td>
    </tr>
    <tr>
      <td>
        <code>ccm_parameters</code>
      </td>
      <td>
        Additional metadata for swaps with Cross-Chain Messaging. Should be set to `None` for simple swaps.
      </td>
      <td><code>Option&lt;(message, gas_amount)&gt;</code></td>
    </tr>
    <tr>
    <td>
      <code>message</code>
    </td>
    <td>
      Message that is passed to the destination address on the destination chain. It must be shorter than 15k bytes.
    </td>
    <td><code>Vec&lt;u8&gt;</code></td>
    </tr>
    <tr>
    <td>
      <code>gasAmount</code>
    </td>
    <td>
      Gas budget for the call on the destination chain. This amount is based
      on the source asset and will be subtracted from the input amount and swapped
      to pay for gas.
    </td>
    <td><code>u64</code></td>
    </tr>
    <tr>
      <td>
        <code>cfParameters</code>
      </td>
      <td>
        Additional metadata for additional features. See [TODO: CF_PARAMETERS link]()
      </td>
      <td><code>Vec&lt;u8&gt;</code></td>
    </tr>
  </tbody>
</table>}

{<table>
  <thead>
    <tr>
      <th width="223">Account</th>
      <th width="371">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <code>data_account</code>
      </td>
      <td>Chainflip's Vault Data Account</td>
    </tr>
    <tr>
      <td>
        <code>agg_key</code>
      </td>
      <td>Chainflip's current aggKey</td>
    </tr>
    <tr>
      <td>
        <code>from</code>
      </td>
      <td>
        Address initiating the swap. This account will pay the transaction fees and the input swap amount.
      </td>
    </tr>
    <tr>
      <td>
        <code>event_data_account</code>
      </td>
      <td>Newly generated keypair's public key</td>
    </tr>
    <tr>
      <td>
        <code>swap_endpoint_data_account</code>
      </td>
      <td>
        Chainflip's Swap Endpoint Data Account
      </td>
    </tr>
    <tr>
    <td>
      <code>system_program</code>
    </td>
    <td>
      Solana System Program Account
    </td>
    </tr>
  </tbody>
</table>}
