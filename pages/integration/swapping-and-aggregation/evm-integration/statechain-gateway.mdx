---

title: StateChain Gateway

description: Description of the State Chain Gateway smart contract for integration purposes.

---

import { Callout } from "@/components";

# Fund and redeem via State Chain Gateway smart contract

As explained in [State Chain Overview](../../../concepts/validator-network/state-chain-flip-gateway.md), the State Chain Gateway contract has mainly two entry points for users that want to interact with the protocol. One is to provide \$FLIP tokens to fund a state chain account and the other is to redeem those tokens.

## Fund a State Chain account

Users can fund a State Chan account by making a smart contract call and providing an amount of $FLIP to be locked in the contract. Tokens need to be approved first by the user to be transferred by the contract.


{<table>

  <thead>
    <tr>
      <th width="223">Param</th>
      <th width="371">Description</th>
      <th width="244.33333333333331">Data type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <code>nodeID</code>
      </td>
      <td>`ChainflipAccountID` (a hex representation of a substrate SS58 encoded public key) of the account to fund.</td>
      <td><code>bytes32</code></td>
    </tr>
    <tr>
      <td>
        <code>amount</code>
      </td>
      <td>Amount of $FLIP tokens to fund. The amount needs to be higher than the minimum funding amount, set to 1 $FLIP as of now.</td>
      <td><code>uint256</code></td>
    </tr>
  </tbody>
</table>}

```solidity
    function fundStateChainAccount(bytes32 nodeID, uint256 amount) external;
```


## Redeem $FLIP

After the user has submitted a redemption request to the State Chain, the protocol will submit the redemption to the State Chain Gateway. The contract will store it as a Redemption struct. The redemption is considered to be pending and can be checked with the view function below.

{<table>

  <thead>
    <tr>
      <th width="223">Param</th>
      <th width="371">Description</th>
      <th width="244.33333333333331">Data type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <code>amount</code>
      </td>
      <td>Amount of $FLIP tokens redeemed</td>
      <td><code>uint256</code></td>
    </tr>
    <tr>
      <td>
        <code>redeemAddress</code>
      </td>
      <td>Ethereum address that will receive the redeemed $FLIP</td>
      <td><code>address</code></td>
    </tr>
    <tr>
      <td>
        <code>startTime</code>
      </td>
      <td>Starting timestamp in which the Redemption can be executed</td>
      <td><code>uint48</code></td>
    </tr>
    <tr>
      <td>
        <code>expiryTime</code>
      </td>
      <td>Timestamp in which the redemption expires and can't be executed anymore</td>
      <td><code>uint48</code></td>
    </tr>    
    <tr>
      <td>
        <code>executor</code>
      </td>
      <td>Address that can execute the redemption. By default any address can execute any redemption.</td>
      <td><code>address</code></td>
    </tr>        
  </tbody>
</table>}

```solidity
    struct Redemption {
        uint256 amount;
        address redeemAddress;
        uint48 startTime;
        uint48 expiryTime;
        address executor;
    }

    function getPendingRedemption(bytes32 nodeID) external view returns (Redemption memory);
```

As previously explained, the fail-safe mechanism adds a 2-day delay between the registry of the redemption and the time when it can be executed. After that delay and until the expiry time, the redemption can be executed to complete the redemption process. In the event of the redemption having specified an executor address, only that address can execute the redemption. Otherwise, any address can execute it.

The protocol doesn't automatically execute the redemptions, the user needs to make smart contract call below specifying the nodeID of the account following the same format as the funding function.

```solidity
    function executeRedemption(bytes32 nodeID) external returns (address, uint256);
```