---

title: LP API

description: The LP API bundle allows liquidity providers to put up orders programmatically through the JIT AMM.

---

import { Callout } from "@/components";

# LP API

<Callout type="warning">These docs are under active development. ðŸš§</Callout>

The LP API bundle exposes a JSON API that allows liquidity providers to put up orders programmatically through the JIT AMM. It connects to a _State Chain_ node, and handles the complexities of submitting and monitoring extrinsics, allowing for simpler integration.

Please also see the [LP RPCs](lp-rpcs) documentation for information on RPCs and subscriptions exposed by the State Chain directly.

## Command line arguments

The `ws_endpoint` should point at a synced RPC node, the `signing_key_file` should be the **private key** for their on-chain account, and that account should already be [funded](../../../perseverance/funding/funding-and-bidding).

```bash copy
> ./target/release/chainflip-lp-api --help

chainflip-lp-api

USAGE:
    chainflip-lp-api [OPTIONS]

OPTIONS:
    -h, --help
            Print help information

        --state_chain.signing_key_file <SIGNING_KEY_FILE>
            [default: /etc/chainflip/keys/signing_key_file]

        --state_chain.ws_endpoint <WS_ENDPOINT>
            [default: ws://localhost:9944]
```

## RPC Parameters

Parameters can be encoded as a JSON array or as an object. The advantage of the latter is that it's more explicit and allows for optional values to be omitted.

### Addresses

Addresses should be encoded according to their host chains:
- Ethereum addresses should be encoded as Hex strings, for example `"0xfa36e03defc6e4d140cc61fcaab9d1fbef18642f"`.
- Polkadot addresses can be encoded using SS58 or Hex strings, for example: `"13zyEWmmLDx63Y99TL9SkxBe1DqPVCrcjXytxM3ZHGRyEJV5"` or `"0x84aec0876dbb3cb7391eeded2eef5fbcf0d1a34f7c9f86f9af205f944b461761"`
- Bitcoin addresses should be encoded using the appropriate bitcoin standard for the address type. For example `"tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx"` is a valid bech32 address on Bitcoin testnet.

### Amounts

JSON only supports numbers up to 2^53. Since many tokens are represented as atomic amounts with 18 decimals, this corresponds for around 0.009 ETH!

Therefore, numbers denoting token amount or prices can be specified either as numbers or encoded as big-endian hex.

For example ETH uses 18 decimal places, so 100ETH is 100,000,000,000,000,000,000 Units. This can be only be encoded as a hex string: `"0x56bc75e2d63100000"`

Another example: USDC uses 6 decimals, so 10USDC is 10,000,000 Units. This fits in a JSON number: `10000000`.

### Assets

Assets are specified as short-form camel-case strings, for example `"Eth"`, `"Flip"`, `"Dot"`.

### Chains

Chains are specified as the full name of the chain, capitalised, for example `"Ethereum"`, `"Bitcoin"`, "`Polkadot"`.

### Order IDs

Order IDs are interpreted as 64-bit integers and as such can be specified using a JSON number, up to `2^53`. Alteratively the ID can be encoded as a hex string, up to 8 bytes (16 hex characters) long.

Order IDs are assigned by the LP, are unique within each pool and for each account, and can be re-used.

## RPC Methods

### `lp_register_account`

Parameters:

None

Return:

- `null` if successful, otherwise an error.

### `lp_liquidity_deposit`

Parameters:

- Asset to be deposited as a camel-case string, e.g. "Eth" or "Dot".

Return:

- Encoded _deposit address_ that you should send the deposit to.

Example:

- Request
  ```sh
  curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "lp_liquidity_deposit", "params": ["Eth"]}' http://localhost:10589
  ```

- Response
  ```json
  {"jsonrpc":"2.0","result":"0x56bd3d36a3f7186d8b5aa24baca687d4fa47b24d","id":1}
  ```

### `lp_register_liquidity_refund_address`

Parameters:

- `chain`: The external chain as a camel-case string, e.g. "Ethereum" or "Polkadot".
- `address`: The refund address for the specified external chain. Any assets associated with that chain will be transferred there if a refund is needed, e.g. "USDC" would be tranferred to the address associated with "Ethereum".

Return:

- The transaction hash of the extrinsic that registered the new withdrawal address.

Example:

- Request
  ```sh
  curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "lp_register_liquidity_refund_address", "params": {"chain": "Ethereum", "address": "0x71C7656EC7ab88b098defB751B7401B5f6d8976F"}}' http://localhost:10589
  ```

- Response
  ```json
  {"jsonrpc":"2.0","result":"0x006595fa7c1010fece1835c91cfb24971eebe3fa75c587b6b4a2b4b5e6dd7387","id":1}
  ```

### `lp_withdraw_asset`

Parameters:

- `asset_amount`: Asset [amount](#amounts) to be withdrawn as u128.
- `asset`: Withdrawn [asset](#assets).
- `destination_address`: The [address](#addresses) to which to send the withdrawn funds. The format depends on the asset's destination chain.

Return:

- Egress id, which is used as the identifier for the operation/s to egress/withdraw the requested funds.

Example:

- Request
  ```sh
  curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "lp_withdraw_asset", "params": [1000, "Usdc", "0x71C7656EC7ab88b098defB751B7401B5f6d8976F"]}' http://localhost:10589
  ```

- Response
  ```json
  {"jsonrpc":"2.0","result":["Ethereum",48],"id":1}
  ```

### `lp_update_range_order`

Parameters:

- `base_asset`: Base [Asset](#assets) as a camel-case string, e.g. "Eth" or "Dot".
- `pair_asset`: Pair [Asset](#assets) as a camel-case string, e.g. "Eth" or "Dot".
- `id`: Numerical [Order ID](#order-ids).
- `tick_range`: (Optional) A JSON array of two JSON Integers in the range [-887272, 887272], representing the lower and upper bound of the order's price range. If not specified, the previous tick range of this order id will be used.
- `increase_or_decrease`: "Increase" or "Decrease", depending on whether the order size should be increased or decreased.
- `size`: A JSON object specifying the change in order size. There are two different ways to provide this:
  1. `{"Liquidity": {"liquidity": <liquidity>}}` where `<liquidity>` is an [amount](#amounts) specifying the size of the order in microUSDC.
  2. &#x20;`{"AssetAmounts":{"maximum":{"base": <amount>, "pair": <amount>}, "minimum":{"base": <amount>, "pair: <amount>}}}` where the [`<amounts>`](#amounts) specify the size of the order in smallest units of the respective asset (base or pair), e.g. For Bitcoin it is in Satoshis. Using "AssetAmounts", the system will try to the change the order by an amount of assets between the specified maxima and minima, subject to available liquidity. If you would not like to change the size of the order you can specify zero values using either "Liquidity" or "AssetAmounts".

Return:

- A chronological list of all the updates that were done as part of the operation. Each item in the list is a JSON object:
  `{ "tick_range": [<tick>, <tick>], "liquidity_total": <liquidity>, "collected_fees": { "base": <amount> , "pair": <amount> }, "increase_or_decrease": <increase_or_decrease>, "liquidity_delta": <liquidity>, "assets_delta": { "base": <amount> , "pair": <amount> } }`
  For example if a lp_updateRangeOrder request moves an existing range order to a new tick_range, the return would contain two of these, one for the decrease to zero/destruction of the order at the previous tick range, and then one for the increase/creation of the order at the new tick range.

### `lp_set_range_order`

Parameters:

- `base_asset`: Base [Asset](#assets) as a camel-case string, e.g. "Eth" or "Dot".
- `pair_asset`: Pair [Asset](#assets) as a camel-case string, e.g. "Eth" or "Dot".
- `id`: Numerical [Order ID](#order-ids).
- `tick_range`: (Optional) A JSON array of two integers in the range [-887272, 887272], representing the lower and upper bound of the order's price range. If not specified, the previous tick range of this order id will be used.
- `size`: A JSON object specifying the new size of the order. This can be provided in two different ways:
  1. &#x20;`{"Liquidity": <liquidity>}` where `<liquidity>` is an [amount](#amounts) specifying the size of the order in microUSDC.
  2. &#x20;`{"AssetAmounts":{"maximum":{"base": <amount>, "pair": <amount>}, "minimum":{"base": <amount>, "pair: <amount>}}}` where the [`<amounts>`](#amounts) specify the size of the order in smallest units of the respective asset (base or pair), e.g. For Bitcoin it is in Satoshis. Using "AssetAmounts", the system will try to the create an order that consumes an amount of assets between the specified maxima and minima, subject to available liquidity. If you would like to close the order you can specify zero values using either "Liquidity" or "AssetAmounts".

Return:

- A chronological list of all the updates that were done as part of the operation. Each item in the list is a JSON object:
  `{ "tick_range": [<tick>, <tick>], "liquidity_total": <liquidity>, "collected_fees": { "base": <amount> , "pair": <amount> }, "increase_or_decrease": <increase_or_decrease>, "liquidity_delta": <liquidity>, "assets_delta": { "base": <amount> , "pair": <amount> } }`
  For example if a lp_setRangeOrder request changes the total size of an existing range order, the return would contain two of these, one for the decrease to zero/destruction of the previous order, and then one for the increase/creation of the order with the new size.

### `lp_update_limit_order`

Parameters:

- `sell_asset`: Sell [Asset](#assets) as a camel-case string, e.g. "Eth" or "Dot".
- `buy_asset`: Buy [Asset](#assets) as a camel-case string, e.g. "Eth" or "Dot".
- `id`: Numerical [Order ID](#order-ids).
- `tick`: (Optional) Price tick in the range [-887272, 887272]. If not specified the previous tick of the order id will be used.
- `increase_or_decrease`: "Increase" or "Decrease", depending on whether the order size should be increased or decreased.
- `amount`: The desired change in size of the order, expressed as an [amount](#amounts).

Return:

- A chronological list of all the updates that were made as a result of the operation. Each item in the list is a JSON object:
  `{ "tick": [<tick>, <tick>], "amount_total": <amount>, "collected_fees": <amount>, "bought_amount": <amount>, "increase_or_decrease": <increase_or_decrease>, "amount_delta": <amount> }`
  For example if an `lp_update_limit_order` request moves the limit order, the return would contain two of these, one for the decrease to zero/destruction of the previous order, and then one for the increase/creation of the order with the price/tick.

#### Example:

- Request:

```bash copy
curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "lp_update_limit_order", "params": {"sell_asset": "Eth", "buy_asset": "Usdc", "id": "1", "tick": 100, "increase_or_decrease": "Decrease", 1 }}' http://localhost:10589
```

- Response:

```json
{
  "jsonrpc":"2.0",
  "result":[
    {
      "tick":100,
      "amount_total":0,
      "collected_fees":0,
      "bought_amount":0,
      "position_delta":[
        "Decrease",
        1
      ]
    }
  ],
  "id":1
}
```

### `lp_set_limit_order`

Parameters:

- `sell_asset`: Sell [Asset](#assets) as a camel-case string, e.g. "Eth" or "Dot".
- `buy_asset`: Buy [Asset](#assets) as a camel-case string, e.g. "Eth" or "Dot".
- `id`: Numerical [Order ID](#order-ids).
- `tick`: (Optional) Price tick in the range [-887272, 887272]. If not specified the previous tick of the order id will be used.
- `amount`: The desired change in size of the order, expressed as an [amount](#amounts).

Return:

- A chronological list of all the updates that were done as part of the operation. Each item in the list is a JSON object:
  `{ "tick": [<tick>, <tick>], "amount_total": <amount>, "collected_fees": <amount>, "bought_amount": <amount>, "increase_or_decrease": <increase_or_decrease>, "amount_delta": <amount> }`
  For example if a `lp_set_limit_order` request moves the limit order, the return would contain two of these, one for the decrease to zero/destruction of the previous order, and then one for the increase/creation of the order with the price/tick.

#### Example:

- Request:

```bash copy
curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "lp_set_limit_order", "params": ["sell_asset": "Eth", "buy_asset": "Usdc", "id": "1", "tick": 100, 1]}' http://localhost:10589
```

- Response:

```json
{
  "jsonrpc":"2.0",
  "result":[
    {
      "tick":-216338,
      "amount_total":0,
      "collected_fees":0,
      "bought_amount":0,
      "position_delta":[
        "Decrease",
        0
      ]
    },
    {
      "tick":100,
      "amount_total":1,
      "collected_fees":0,
      "bought_amount":0,
      "position_delta":[
        "Increase",
        1
      ]
    }
  ],
  "id":1
}
```


### ` lp_asset_balances`

Parameters:

None

Return:

- A list of all assets and their free balance in JSON format.

### `lp_get_open_swap_channels`

Parameters:

None

Return:

- All the open swap channels and their associated details in JSON format.

## Working Example

```bash copy
./target/release/chainflip-lp-api \
 --state_chain.ws_endpoint=ws://localhost:9944 \
 --state_chain.signing_key_file /path/to/my/signing_key

ðŸŽ™ Server is listening on 0.0.0.0:80.
```

Default values are `ws://localhost:9944` and `/etc/chainflip/keys/signing_key_file`

Then in another terminal:

```bash copy
> curl -H "Content-Type: application/json" \
    -d '{"id":1, "jsonrpc":"2.0", "method": "lp_register_account", "params": [0]}' \
    http://localhost:80

{"jsonrpc":"2.0","result":null,"id":1}

# This method take a little while to respond because it submits and waits for finality. So make sure the request doesn't block.
# Parameters are: [ asset ].
> curl -H "Content-Type: application/json" \
    -d '{"id":1, "jsonrpc":"2.0", "method": "lp_liquidity_deposit", "params": ["Eth"]}' \
    http://localhost:80

# The result is the hex-encoded deposit address.
{"jsonrpc":"2.0","result":"0x350ec3dfd773978277868212d9f1319cbc93a8bf","id":1}
```

## Limitations

- It doesn't seem to work with **`wss`**, so make sure the address is specified with **`ws`**. It should be ok since we're not going to expose this externally.
