---

title: LP API

description: The LP API bundle allows liquidity providers to put up orders programmatically through the JIT AMM.

---

import { Callout } from "@/components";

# LP API

<Callout type="warning">These docs are under active development. ðŸš§</Callout>

The LP API bundle exposes a JSON API that allows liquidity providers to easily more easily integrate with Chainflip, and it built on top of rpcs exposed directly by State Chain. It connects to a _State Chain_ node, and handles the complexities of submitting extrinsics, and provides some utilities for assessing the state of the liquidity pools.

## Command line arguments

The `ws_endpoint` should point at a synced RPC node, the `signing_key_file` should be the **private key** for their on-chain account, and that account should already be [funded](../../../perseverance/funding/funding-and-bidding).

```bash copy
./chainflip-lp-api --help
```
```sh
chainflip-lp-api

USAGE:
    chainflip-lp-api [OPTIONS]

OPTIONS:
    -h, --help
            Print help information

        --port <PORT>
            The port number on which the LP server will listen for connections. Use 0 to assign a
            random port. [default: 80]

        --state_chain.signing_key_file <SIGNING_KEY_FILE>
            A path to a file that contains the LPs secret key for signing extrinsics. 
            [default: /etc/chainflip/keys/signing_key_file]

        --state_chain.ws_endpoint <WS_ENDPOINT>
            The state chain nodes RPC endpoint. [default: ws://localhost:9944]
    
    -v, --version 
            Print the version of the API
```

## RPC Parameters

The parameters list of any JSONRPC call can be encoded as a JSON array or as an object. The advantage of the latter is that it's more explicit and allows for optional values to be omitted.

### Addresses

Addresses should be encoded according to their host chains:
- Ethereum addresses should be encoded as Hex strings, for example `"0xfa36e03defc6e4d140cc61fcaab9d1fbef18642f"`.
- Polkadot addresses can be encoded using SS58 or Hex strings, for example: `"13zyEWmmLDx63Y99TL9SkxBe1DqPVCrcjXytxM3ZHGRyEJV5"` or `"0x84aec0876dbb3cb7391eeded2eef5fbcf0d1a34f7c9f86f9af205f944b461761"`
- Bitcoin addresses should be encoded using the appropriate bitcoin standard for the address type. For example `"tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx"` is a valid bech32 address on Bitcoin testnet.

### Amount

An integer encoded as a big-endian hex string, between `0` and `2^128 - 1`, representing a quantity of a token in it's smallest unit.

For example, ETH uses 18 decimal places, so 100ETH is 100,000,000,000,000,000,000 Units, which encoded as hex is `"0x56bc75e2d63100000"`. As another example, USDC uses 6 decimals, so 10USDC is 10,000,000 Units, which encoded as hex is `"0x989680"`.

### Liquidity

An integer encoded as a big-endian hex string, between `0` and `2^128 - 1`, representing the amount of liquidity in/the size of a range order.

See [range orders](./range-order) for more details. // TODO

### Asset

Assets are specified as a `{ chain, asset }` object, where the [chain](#chains) is as described below, and the asset is an upper-case string. Assets returned from the RPCs will always take the explicit form, for example `{ chain: "Ethereum", asset: "ETH" }`.

If the chain is unambiguous (for example for the native currencies), the asset can be submitted simply as the upper-case string. For example, for BTC, `"BTC"` and `{ chain: "Bitcoin", asset: "BTC" }` are both valid and resolve to the same asset.

### Chain

Chains are specified as the full name of the chain, capitalised, for example `"Ethereum"`, `"Bitcoin"`, "`Polkadot"`.

### Order IDs

Order IDs are integers encoded as a big-endian hex string, between `0` and `2^64 - 1`.

Order IDs are assigned by the LP, are unique within each pool, order type, side, and account, and can be re-used. Note that two limit orders, one buy and one sell, in the same pool (i.e. ETH-USDC) could simultaneously have the same ID, but two buys or two sells could not.

Depending on the order type you need different information to uniquely identify it:

- For limit orders, you need the LP who created it, the pool it is in i.e. the base and quote asset, the side, and its Order ID.
- For range orders, you need to know the LP who created it, the pool it exists in, and its Order Id.

### Order Updates

Changes in order size are communicated via an `increase_or_decrease` object which has these structures for range orders:

```json
{
  "increase": <range_order_size>
}
// OR
{
  "decrease": <range_order_size>
}
```

And this structure for limit orders:

```json
{
  "increase": <amount>
}
// OR for a decrease:
{
  "decrease": <amount>
}
```

### Ticks

An integer between `-887272` and `887272` inclusively, representing a price. To calculate the nearest tick to a given price in the quote asset, using this formula: `log1.0001(price * <QUOTE_ASSET_PRECISION> / <BASE_ASSET_PRECISION>)`. The tick representation of a price can be calculated by taking the log1.0001 of the price in the quote asset, and rounded down to the nearest integer. A tick can be turned into a price (into the quote asset) with this formula: `(1.0001^tick) * <BASE_ASSET_PRECISION> / <QUOTE_ASSET_PRECISION>`. `<ASSET_PRECISION>` for ETH would be `10^18` and for USDC it would be `10^6`.

### Wait For

Some RPCs that submit extrinsics take an optional parameter `wait_for`, this allows you to control under what condition the RPC will wait for until returning successfully. It can have these values:

- `NoWait`/`submitted`: This will cause the RPC to return once the extrinsic has been successfully submitted to the node.
- `InBlock`/`included`: This will cause the RPC to return once the extrinsic has been included in a block.
- `Finalized`/`finalized`: This will cause the RPC to return once the extrinsic has been included in a block that has been finalized. This is the default if the argument is not specified.

This option also affects the data returned by the rpcs, see [Wait For Result](#wait-for-result).

### Wait For Result

RPCs that take a `wait_for` parameter when successful will return a object with one of these structures:

```json
// For "wait_for: submitted"
{
  "tx_hash": <hex encoded transaction hash of the submitted extrinsic>
}
// OR for "wait_for: included/finalized"
{
  "tx_details": {
    "tx_hash": <hex encoded transaction hash of the submitted extrinsic>,
    "response": <...>,
  }
}
```

### Range order size

Range orders are made up from a ratio of both base and quotes assets. This ratio is determined by the current price of the pool, and must remain constant. Therfore the amounts that are added or removed from a range order must match this ratio.

When describing the size of a range order you can use a liquidity number which is independent of the ratio, and so any liquidity number is valid. As the liquidity number is not an easily understandable concept (See ... TODO), alternatively you can specify ranges for the amounts of both assets you want to add or remove or set the order to contain, but this will only be valid if an amount of both assets exists inside the ranges that matches the range order's required ratio.

For example if the ratio is 1 ETH:50 USDC, and you specify minimums of 10 ETH:2000 USDC, and maximums of 100 ETH:10000 USDC. It will pick 100 ETH:5000 USDC, as these are the largest amounts inside the specified ranges that match the required ratio. But if the maximums where instead 20 ETH:10000 USDC then there is no amount of ETH or USDC inside those ranges that matches the required 1 ETH:50 USDC ratio. 

### Price

A 256 bit unsigned fixed point number, with 128 fractional bits. Fixed point numbers work similarly to integers, expect instead of the all the bits representing positive integer powers of 2, the lower bits represent negative integer powers of two. For example if you the 8 bit unsigned fixed point number with 4 fractional bits, `01011100`. This represents ``

### Square Root Price

### Side




## RPC Methods

### `lp_register_account`

Submits an extrinsic that registers your account as an LP, so that allow this account can provide liquidity. The role of an account only needs to be registered once, and cannot be changed after it has been. It waits for the extrinsic to be successfully included in a block, and returns an error if the extrinsic expires before being included, or the extrinsic dispatch fails on-chain. 

Parameters: None

Returns: The transaction hash of the extrinsic, otherwise an error.

### `lp_liquidity_deposit`

Submits an extrinsic that opens a deposit address that you can send assets to. Once any assets you send are detected they will be credited to this account's free balance, and can then be used to create orders. We recommend waiting until the extrinsic is finalized before sending any assets to the desposit address to ensure the assets are correctly credited to your account.

Parameters:
- `asset`: The [asset](#assets) to be deposited.
- `wait_for`: (Optional) The [condition](#wait-for) to wait for before considering the extrinsic successful.

Return:
- The encoded deposit [address](#foreign-chain-addresses) that you should send the deposit to.

#### Example
```sh
curl -H "Content-Type: application/json" -d '{
  "id":1,
  "jsonrpc":"2.0",
  "method": "lp_liquidity_deposit",
  "params": ["ETH"]
}' http://localhost:10589
```
```json
{"jsonrpc":"2.0","result":"0x56bd3d36a3f7186d8b5aa24baca687d4fa47b24d","id":1}
```

### `lp_register_liquidity_refund_address`

Parameters:
- `chain`: The external [chain](#chains).
- `address`: The refund [address](#Addresses) for the specified external chain. Any assets associated with that chain will be transferred there if a refund is needed, e.g. "USDC" would be transferred to the address associated with "Ethereum".

Return:
- The transaction hash of the extrinsic that registered the new withdrawal [address](#foreign-chain-addresses).

#### Example
```sh
curl -H "Content-Type: application/json" -d '{
  "id":1,
  "jsonrpc":"2.0",
  "method": "lp_register_liquidity_refund_address",
  "params": {
    "chain": "Ethereum",
    "address": "0x71C7656EC7ab88b098defB751B7401B5f6d8976F"
  }
}' http://localhost:10589
```
```json
{"jsonrpc":"2.0","result":"0x006595fa7c1010fece1835c91cfb24971eebe3fa75c587b6b4a2b4b5e6dd7387","id":1}
```

### `lp_withdraw_asset`

Parameters:

- `asset_amount`: Asset [amount](#amounts) to be withdrawn.
- `asset`: Withdrawn [asset](#assets).
- `destination_address`: The [address](#addresses) to which to send the withdrawn funds.

Return:

Egress id, which is used as the identifier for the operation/s to egress/withdraw the requested funds.

#### Example

- Request
  ```sh
  curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "lp_withdraw_asset", "params": [1000, "USDC", "0x71C7656EC7ab88b098defB751B7401B5f6d8976F"]}' http://localhost:10589
  ```

- Response
  ```json
  {"jsonrpc":"2.0","result":["Ethereum",48],"id":1}
  ```

### `lp_update_range_order`

Parameters:

- `base_asset`: Base [Asset](#assets).
- `pair_asset`: Pair [Asset](#assets).
- `id`: Numerical [Order ID](#order-ids).
- `tick_range`: (Optional) A JSON array of two JSON Integers in the range [-887272, 887272], representing the lower and upper bound of the order's price range. If not specified, the previous tick range of this order id will be used.
- `size_change`: An `increase_or_decrease` JSON object specifying the change in order size, where `<increase_or_decrease>` is either "increase" or "decrease". There are two different ways to provide this:
  1. `{<increase_or_decrease>: {"Liquidity": {"liquidity": <liquidity>}}}` where `<liquidity>` is an [amount](#amounts) specifying the size of the order in microUSDC.
  2. `{<increase_or_decrease>: {"AssetAmounts":{"maximum":{"base": <amount>, "pair": <amount>}, "minimum":{"base": <amount>, "pair: <amount>}}}}` where the [`<amounts>`](#amounts) specify the size of the order in smallest units of the respective asset (base or pair), e.g. For Bitcoin it is in Satoshis. Using "AssetAmounts", the system will try to the change the order by an amount of assets between the specified maxima and minima, subject to available liquidity. If you would not like to change the size of the order you can specify zero values using either "Liquidity" or "AssetAmounts".

Return:

A chronological list of all the [updates](#order-updates) that were done as part of the operation. Each item in the list is a JSON object:

```json
  { 
    "base_asset:" <asset>,
    "pair_asset": <asset>,
    "id": <order_id>,
    "tick_range": [<tick>, <tick>], 
    "liquidity_total": <liquidity>, 
    "collected_fees": { "base": <amount> , "pair": <amount> }, 
    "size_change": { <increase_or_decrease>: {
      "liquidity": <liquidity>,
      "amounts": {"base": <amount>, "pair": <amount>}
      }
    }
  }
```

For example if a `lp_update_range_order` request moves an existing range order to a new tick_range, the return would contain two of these, one for the decrease to zero/destruction of the order at the previous tick range, and then one for the increase/creation of the order at the new tick range.

### `lp_set_range_order`

Parameters:

- `base_asset`: Base [Asset](#assets).
- `pair_asset`: Pair [Asset](#assets).
- `id`: Numerical [Order ID](#order-ids).
- `tick_range`: (Optional) A JSON array of two integers in the range [-887272, 887272], representing the lower and upper bound of the order's price range. If not specified, the previous tick range of this order id will be used.
- `size`: A JSON object specifying the order size. There are two different ways to provide this:
  1. `{"Liquidity": {"liquidity": <liquidity>}}` where `<liquidity>` is an [amount](#amounts) specifying the size of the order in microUSDC.
  2. `{"AssetAmounts":{"maximum":{"base": <amount>, "pair": <amount>}, "minimum":{"base": <amount>, "pair: <amount>}}}` where the [`<amounts>`](#amounts) specify the size of the order in smallest units of the respective asset (base or pair), e.g. For Bitcoin it is in Satoshis. Using "AssetAmounts", the system will try to set the order size to an amount of assets between the specified maxima and minima, subject to available liquidity.

Return:

A chronological list of all the [updates](#order-updates) that were done as part of the operation. Each item in the list is a JSON object:

```json
  { 
    "base_asset:" <asset>,
    "pair_asset": <asset>,
    "id": <order_id>,
    "tick_range": [<tick>, <tick>], 
    "liquidity_total": <liquidity>, 
    "collected_fees": { "base": <amount> , "pair": <amount> }, 
    "size_change": { <increase_or_decrease>: {
      "liquidity": <liquidity>,
      "amounts": {"base": <amount>, "pair": <amount>}
      }
    }
  }
```

For example if a `lp_set_range_order` request changes the total size of an existing range order, the return would contain two of these, one for the decrease to zero/destruction of the previous order, and then one for the increase/creation of the order with the new size.

### `lp_update_limit_order`

Update a limit order by increasing or decreasing its size.

Parameters:

- `sell_asset`: Sell [Asset](#assets).
- `buy_asset`: Buy [Asset](#assets).
- `id`: Numerical [Order ID](#order-ids).
- `tick`: (Optional) Price tick in the range [-887272, 887272]. If not specified the previous tick of the order id will be used.
- `amount_change`: The desired change [amount](#amounts) as a increase or decrease json object: `{"increase": <amount>}` or `{"decrease": <amount>}`.
- `dispatch_at`: (Optional) Schedules the dispatch of `lp_update_limit_order` on a given block. If the transaction is included after the `dispatch_at` block, it has no effect.

Return:

A chronological list of all the [updates](#order-updates) that were made as a result of the operation. Each item in the list is a JSON object:

Note that during the order's lifetime, swaps may be executed against it, and this results in quantities of the `buy_asset` accumulating. These are swept into the free balance as a result of any update to any order in the same pool. This swept amount is what `bought_amount` refers to.

```json
{
  "sell_asset": <asset>,
  "buy_asset": <asset>,
  "id": <order_id>,
  "tick": <tick>,
  "amount_total": <amount>,
  "collected_fees": <amount>,
  "bought_amount": <amount>,
  "amount_change": { <increase_or_decrease>: <amount> }
}
```

  For example if an `lp_update_limit_order` request moves the limit order, the return would contain two of these, one for the decrease to zero/destruction of the previous order, and then one for the increase/creation of the order with the price/tick.

#### Example:

- Request:

```bash copy
curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "lp_update_limit_order", "params": {"sell_asset": "ETH", "buy_asset": {"chain": "Ethereum", "asset": "USDC"}, "id": "1", "tick": 100, "amount_change": {"decrease": 1 }}}' http://localhost:10589
```

- Response:

```json
{
  "jsonrpc":"2.0",
  "result":[
    {
      "sell_asset": { "chain": "Ethereum", "asset": "ETH" },
      "buy_asset": { "chain": "Ethereum", "asset": "USDC" },
      "tick":100,
      "amount_total":0,
      "collected_fees":0,
      "bought_amount":0,
      "amount_change":{ "decrease": 1 }
    }
  ],
  "id":1
}
```

> **_NOTE:_** If you pass the `dispatch_at` parameter the response may not return any results due to the fact that order is not created/updated yet. Instead the `result` array will be empty. The exception to this would be if the transaction is included in the `dispatch_at` block, in which case the operation is executed immediately. If the `dispatch_at` block has already elapsed, this method returns an error.

### `lp_set_limit_order`

Parameters:

- `sell_asset`: Sell [Asset](#assets) as a camel-case string, e.g. "Eth" or "Dot".
- `buy_asset`: Buy [Asset](#assets) as a camel-case string, e.g. "Eth" or "Dot".
- `id`: Numerical [Order ID](#order-ids).
- `tick`: (Optional) Price tick in the range [-887272, 887272]. If not specified the previous tick of the order id will be used.
- `amount`: The desired size of the order, expressed as an [amount](#amounts).
- `dispatch_at`: (Optional) Schedules the dispatch of `lp_set_limit_order` on a given block. If the transaction is included after the `dispatch_at` block, it has no effect.

Return:

- A chronological list of all the [updates](#order-updates) that were made as part of the operation. Each item in the list is a JSON object:

```json
{
  "sell_asset": <asset>,
  "buy_asset": <asset>,
  "id": <order_id>,
  "tick": <tick>,
  "amount_total": <amount>,
  "collected_fees": <amount>,
  "bought_amount": <amount>,
  "amount_change": { <increase_or_decrease>: <amount> }
}
```

  For example if a `lp_set_limit_order` request moves the limit order, the return would contain two of these, one for the decrease to zero/destruction of the previous order, and then one for the increase/creation of the order with the price/tick.

#### Example:

Imagine an order with 1 exists at tick -216338.

- Request:

```bash copy
curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "lp_set_limit_order", "params": {"sell_asset": "ETH", "buy_asset": "USDC", "id": "1", "tick": 100, "amount": 1}}' http://localhost:10589
```

- Response:

```json
{
  "jsonrpc":"2.0",
  "result":[
    {
      "sell_asset": { "chain": "Ethereum", "asset": "ETH" },
      "buy_asset": { "chain": "Ethereum", "asset": "USDC" },
      "tick": -216338,
      "amount_total":0,
      "collected_fees":0,
      "bought_amount":0,
      "amount_change":{ "decrease": 1 }
    },
    {
      "sell_asset": { "chain": "Ethereum", "asset": "ETH" },
      "buy_asset": { "chain": "Ethereum", "asset": "USDC" },
      "tick": 100,
      "amount_total":1,
      "collected_fees":0,
      "bought_amount":0,
      "amount_change":{ "increase": 1 }
    },
  ],
  "id":1
}
```

> **_NOTE:_** If you pass the `dispatch_at` parameter the response may not return any results due to the fact that order is not created/updated yet. Instead the `result` array will be empty. The exception to this would be if the transaction is included in the `dispatch_at` block, in which case the operation is executed immediately. If the `dispatch_at` block has already elapsed, this method returns an error.

### `lp_asset_balances`

Parameters:

None

Return:

- An JSON object where each key is a Chain, and the values are arrays of `{ asset, balance }` pairs.

Example:

Request:

```bash copy
curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "lp_asset_balances", "params":[]}' http://localhost:10589
```

Response:

```json
{
  "jsonrpc":"2.0",
  "result":{
    "Ethereum":[
      {"asset":"ETH","balance":19812894985665653779},
      {"asset":"FLIP","balance":1229999999999994975},
      {"asset":"USDC","balance":600042386654}
    ],
    "Polkadot":[
      {"asset":"DOT","balance":10140000010}
    ],
    "Bitcoin":[
      {"asset":"BTC","balance":101099}
    ]
  },
  "id":1
}
```

### `lp_get_open_swap_channels`

Parameters:

None

Return:

- All the open swap channels and their associated details in JSON format.

## Working Example

1. Run the LP API server with the following command:
```bash copy
./chainflip-lp-api \
 --state_chain.ws_endpoint ws://localhost:9944 \
 --state_chain.signing_key_file /path/to/my/signing_key \
 --port 80 # or whatever port you want to use
```
It will print `ðŸŽ™ Server is listening on 0.0.0.0:80.` and continue to run.

2. In another terminal:
Register as an liquidity provider if you are not already.
```bash copy
curl -H "Content-Type: application/json" \
    -d '{"id":1, "jsonrpc":"2.0", "method": "lp_register_account", "params": [0]}' \
    http://localhost:80
```
Returns `{"jsonrpc":"2.0","result":null,"id":1}`

3. Request a liquidity deposit address:
```bash copy
curl -H "Content-Type: application/json" \
    -d '{"id":1, "jsonrpc":"2.0", "method": "lp_liquidity_deposit", "params": ["Eth"]}' \
    http://localhost:80
```
The response is a hex-encoded deposit address: `{"jsonrpc":"2.0","result":"0x350ec3dfd773978277868212d9f1319cbc93a8bf","id":1}`.

## Limitations

- It doesn't seem to work with **`wss`**, so make sure the address is specified with **`ws`**. It should be ok since we're not going to expose this externally.
